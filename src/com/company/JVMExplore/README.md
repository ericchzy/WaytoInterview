# 快速阅览

## Lock/Synchronized两种方式保证程安全的区别

- Lock使用起来比较灵活，但需要手动释放和开启；采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；

- Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；

- 在并发量比较小的情况下，使用synchronized是个不错的选择，但是在并发量比较高的情况下，其性能下降很严重，此时Lock是个不错的方案。

- 使用Lock的时候，等待/通知 是使用的Condition对象的await()/signal()/signalAll()  ，而使用synchronized的时候，则是对象的wait()/notify()/notifyAll();由此可以看出，使用Lock的时候，粒度更细了，一个Lock可以对应多个Condition。

- 虽然Lock缺少了synchronized隐式获取释放锁的便捷性，但是却拥有了锁获取与是释放的可操作性、可中断的获取锁以及超时获取锁等多种synchronized所不具备的同步特性;


## OOM各种姿势

- 堆内存溢出（不断新建静态对象而不释放其唯一引用）

- 线程栈溢出（不断新建线程调用死循环方法）

- 方法栈溢出（调用无返回条件的递归方法）

- 运行时常量池内存溢出（在JDK8中，永久代已完全被元空间(Meatspace)所取代，故此处抛出错误和堆内存溢出一样）

## 死锁问题

死锁问题是在多线程编程过程经常出现的问题，可以被认为是线程间切换消耗系统资源的极端情况。在死锁时，线程间相互等待资源，而又不释放自身的资源，导致无穷无尽的等待，其结果是系统任务永远无法执行完成。死锁问题是在多线程开发中应该坚决避免和杜绝的问题。
                                            
一般来说，要出现死锁问题需要满足以下条件：

1. 互斥条件：一个资源每次只能被一个线程使用。

2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。

3. 不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。

4. 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

只要破坏死锁 4 个必要条件之一中的任何一个，死锁问题就能被解决。死锁解决方案大多需要程序员才业务逻辑设计层面彻底杜绝多线程死锁的出现

- 进程在运行前申请得到所有的资源，否则该进程不能进入准备执行状态。此方法会导致程序的资源利用率和进程并发性降低

- 避免资源申请环路，即对资源事先分类编号，按号分配。这种方式可以有效提高资源的利用率和系统吞吐量，但是增加了系统开销，增大了进程对资源的占用时间。
